<!DOCTYPE html>
<html lang="en">
<head>
    <title>AQOfflineRenderTest: iPublicUtility/CAStreamBasicDescription.cpp</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Sample Code">
    <script>String.prototype.cleanUpURL=function(){var c,b="",a=this;if(this.match("#")){b="#"+this.split("#")[1];a=this.split("#")[0]}a=a.replace(/\/\.\/|([^:])\/\//g,"$1/");if(a==="./"){return""+b}while(a!==c){c=a;a=a.replace(/[\/][^\/]+\/+\.\.\//,"/")}a=a.replace(/^.[^\/]+\/+\.\.\//,"");return a+b};(function(){var a="../../../";var c=window.location.pathname;var b=(c.slice(0,c.lastIndexOf("/"))+"/"+a).cleanUpURL();if(top.location.href==window.location.href){if("createTouch" in document){if(document.getElementById("book-resource-type").content!=="Standalone"){switch(navigator.platform){case"iPad":window.location.replace(a+"ipad/#"+c.replace(b,"")+window.location.hash);break;case"iPhone":break}}}else{window.location.replace(a+(window.location.protocol=="file:"?"index.html":"")+"#"+c.replace(b,"")+window.location.hash)}}})();</script>
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/DTS40008413">
    <meta id="date" name="date" content="2010-06-28">
    <meta id="description" name="description" content="Demonstrates using Audio Queue offline render functionality using the AudioQueueOfflineRender API.">
    <meta id="book-title" name="book-title" content="AQOfflineRenderTest">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="book-assignments" name="book-assignments" content="{Type/Sample Code}, {Framework/Media Layer/AudioToolbox}, {Topic/Audio & Video/Audio}">
    
    
    <meta id="generator" name="generator" content="Gutenberg 26027">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2010 Apple Inc. All Rights Reserved.">
    <meta name = "viewport" content = "width = device-width" >
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="iPublicUtility/CAStreamBasicDescription.cpp">
    <meta id="resources-uri" name="resources-uri" content="../../../Resources/545">
    <link id="book-index-page" rel="Start" title="AQOfflineRenderTest" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="iPublicUtility_CAStreamBasicDescription_h.html">
    <link id="previous-page" rel="Prev" type="text/html" href="iPublicUtility_CAMath_h.html">
    <link rel="stylesheet" type="text/css" href="../../../Resources/545/CSS/ac_media.css" charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../../Resources/545/CSS/devpubs.css" charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../../Resources/545/CSS/docs.css" charset="utf-8">
    <!--[if IE]><link rel="stylesheet" type="text/css" href="../../../Resources/545/CSS/ie.css"><![endif]-->
    
<link rel="stylesheet" type="text/css" href="../../../Resources/545/CSS/xcode4.css" charset="utf-8">
</head>    
<body><a name="//apple_ref/doc/uid/DTS40008413-iPublicUtility_CAStreamBasicDescription_cpp" title="iPublicUtility/CAStreamBasicDescription.cpp"></a>
    <article id="contents" tabindex="0" role="main">
        <!-- CONTENTS -->
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='iPublicUtility_CAStreamBasicDescription_h.html'>Next</a><a class='previousLink' rel='prev' href='iPublicUtility_CAMath_h.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/DTS40008413-iPublicUtility_CAStreamBasicDescription_cpp-DontLinkElementID_12" title="iPublicUtility/CAStreamBasicDescription.cpp"></a>
    <br /><h1 id="pageTitle">iPublicUtility/CAStreamBasicDescription.cpp</h1>
    <div class="codesample clear"><table><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre>     File: CAStreamBasicDescription.cpp<span></span></pre></td></tr><tr><td scope="row"><pre> Abstract: <span></span></pre></td></tr><tr><td scope="row"><pre>  Version: 1.2<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple<span></span></pre></td></tr><tr><td scope="row"><pre> Inc. ("Apple") in consideration of your agreement to the following<span></span></pre></td></tr><tr><td scope="row"><pre> terms, and your use, installation, modification or redistribution of<span></span></pre></td></tr><tr><td scope="row"><pre> this Apple software constitutes acceptance of these terms.  If you do<span></span></pre></td></tr><tr><td scope="row"><pre> not agree with these terms, please do not use, install, modify or<span></span></pre></td></tr><tr><td scope="row"><pre> redistribute this Apple software.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> In consideration of your agreement to abide by the following terms, and<span></span></pre></td></tr><tr><td scope="row"><pre> subject to these terms, Apple grants you a personal, non-exclusive<span></span></pre></td></tr><tr><td scope="row"><pre> license, under Apple's copyrights in this original Apple software (the<span></span></pre></td></tr><tr><td scope="row"><pre> "Apple Software"), to use, reproduce, modify and redistribute the Apple<span></span></pre></td></tr><tr><td scope="row"><pre> Software, with or without modifications, in source and/or binary forms;<span></span></pre></td></tr><tr><td scope="row"><pre> provided that if you redistribute the Apple Software in its entirety and<span></span></pre></td></tr><tr><td scope="row"><pre> without modifications, you must retain this notice and the following<span></span></pre></td></tr><tr><td scope="row"><pre> text and disclaimers in all such redistributions of the Apple Software.<span></span></pre></td></tr><tr><td scope="row"><pre> Neither the name, trademarks, service marks or logos of Apple Inc. may<span></span></pre></td></tr><tr><td scope="row"><pre> be used to endorse or promote products derived from the Apple Software<span></span></pre></td></tr><tr><td scope="row"><pre> without specific prior written permission from Apple.  Except as<span></span></pre></td></tr><tr><td scope="row"><pre> expressly stated in this notice, no other rights or licenses, express or<span></span></pre></td></tr><tr><td scope="row"><pre> implied, are granted by Apple herein, including but not limited to any<span></span></pre></td></tr><tr><td scope="row"><pre> patent rights that may be infringed by your derivative works or by other<span></span></pre></td></tr><tr><td scope="row"><pre> works in which the Apple Software may be incorporated.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> The Apple Software is provided by Apple on an "AS IS" basis.  APPLE<span></span></pre></td></tr><tr><td scope="row"><pre> MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION<span></span></pre></td></tr><tr><td scope="row"><pre> THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS<span></span></pre></td></tr><tr><td scope="row"><pre> FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND<span></span></pre></td></tr><tr><td scope="row"><pre> OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL<span></span></pre></td></tr><tr><td scope="row"><pre> OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<span></span></pre></td></tr><tr><td scope="row"><pre> SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<span></span></pre></td></tr><tr><td scope="row"><pre> INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,<span></span></pre></td></tr><tr><td scope="row"><pre> MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED<span></span></pre></td></tr><tr><td scope="row"><pre> AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),<span></span></pre></td></tr><tr><td scope="row"><pre> STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE<span></span></pre></td></tr><tr><td scope="row"><pre> POSSIBILITY OF SUCH DAMAGE.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> Copyright (C) 2010 Apple Inc. All Rights Reserved.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#include "CAStreamBasicDescription.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#include "CAMath.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#if !defined(__COREAUDIO_USE_FLAT_INCLUDES__)<span></span></pre></td></tr><tr><td scope="row"><pre>    #include &lt;CoreFoundation/CFByteOrder.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>    #include &lt;CFByteOrder.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#if TARGET_OS_WIN32<span></span></pre></td></tr><tr><td scope="row"><pre>    #include &lt;stddef.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#pragma mark    This file needs to compile on earlier versions of the OS, so please keep that in mind when editing it<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>const AudioStreamBasicDescription   CAStreamBasicDescription::sEmpty = { 0.0, 0, 0, 0, 0, 0, 0, 0, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CAStreamBasicDescription::CAStreamBasicDescription(double inSampleRate,     UInt32 inFormatID,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    UInt32 inBytesPerPacket,    UInt32 inFramesPerPacket,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    UInt32 inBytesPerFrame,     UInt32 inChannelsPerFrame,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    UInt32 inBitsPerChannel,    UInt32 inFormatFlags)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    mSampleRate = inSampleRate;<span></span></pre></td></tr><tr><td scope="row"><pre>    mFormatID = inFormatID;<span></span></pre></td></tr><tr><td scope="row"><pre>    mBytesPerPacket = inBytesPerPacket;<span></span></pre></td></tr><tr><td scope="row"><pre>    mFramesPerPacket = inFramesPerPacket;<span></span></pre></td></tr><tr><td scope="row"><pre>    mBytesPerFrame = inBytesPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>    mChannelsPerFrame = inChannelsPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>    mBitsPerChannel = inBitsPerChannel;<span></span></pre></td></tr><tr><td scope="row"><pre>    mFormatFlags = inFormatFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>    mReserved = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>char *CAStreamBasicDescription::AsString(char *buf, size_t bufsize) const<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char *theBuffer = buf;<span></span></pre></td></tr><tr><td scope="row"><pre>    int nc;<span></span></pre></td></tr><tr><td scope="row"><pre>    char formatID[5];<span></span></pre></td></tr><tr><td scope="row"><pre>    *(UInt32 *)formatID = CFSwapInt32HostToBig(mFormatID);<span></span></pre></td></tr><tr><td scope="row"><pre>    formatID[4] = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre>    nc = snprintf(buf, bufsize, "%2d ch, %6.0f Hz, '%-4.4s' (0x%08X) ", (int)NumberChannels(), mSampleRate, formatID, (int)mFormatFlags);<span></span></pre></td></tr><tr><td scope="row"><pre>    buf += nc; bufsize -= nc;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (mFormatID == kAudioFormatLinearPCM) {<span></span></pre></td></tr><tr><td scope="row"><pre>        bool isInt = !(mFormatFlags &amp; kLinearPCMFormatFlagIsFloat);<span></span></pre></td></tr><tr><td scope="row"><pre>        int wordSize = SampleWordSize();<span></span></pre></td></tr><tr><td scope="row"><pre>        const char *endian = (wordSize &gt; 1) ? <span></span></pre></td></tr><tr><td scope="row"><pre>            ((mFormatFlags &amp; kLinearPCMFormatFlagIsBigEndian) ? " big-endian" : " little-endian" ) : "";<span></span></pre></td></tr><tr><td scope="row"><pre>        const char *sign = isInt ? <span></span></pre></td></tr><tr><td scope="row"><pre>            ((mFormatFlags &amp; kLinearPCMFormatFlagIsSignedInteger) ? " signed" : " unsigned") : "";<span></span></pre></td></tr><tr><td scope="row"><pre>        const char *floatInt = isInt ? "integer" : "float";<span></span></pre></td></tr><tr><td scope="row"><pre>        char packed[32];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (wordSize &gt; 0 &amp;&amp; PackednessIsSignificant()) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (mFormatFlags &amp; kLinearPCMFormatFlagIsPacked)<span></span></pre></td></tr><tr><td scope="row"><pre>                sprintf(packed, "packed in %d bytes", wordSize);<span></span></pre></td></tr><tr><td scope="row"><pre>            else<span></span></pre></td></tr><tr><td scope="row"><pre>                sprintf(packed, "unpacked in %d bytes", wordSize);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else<span></span></pre></td></tr><tr><td scope="row"><pre>            packed[0] = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre>        const char *align = (wordSize &gt; 0 &amp;&amp; AlignmentIsSignificant()) ?<span></span></pre></td></tr><tr><td scope="row"><pre>            ((mFormatFlags &amp; kLinearPCMFormatFlagIsAlignedHigh) ? " high-aligned" : " low-aligned") : "";<span></span></pre></td></tr><tr><td scope="row"><pre>        const char *deinter = (mFormatFlags &amp; kAudioFormatFlagIsNonInterleaved) ? ", deinterleaved" : "";<span></span></pre></td></tr><tr><td scope="row"><pre>        const char *commaSpace = (packed[0]!='\0') || (align[0]!='\0') ? ", " : "";<span></span></pre></td></tr><tr><td scope="row"><pre>        char bitdepth[20];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#if CA_PREFER_FIXED_POINT<span></span></pre></td></tr><tr><td scope="row"><pre>        int fracbits = (mFormatFlags &amp; kLinearPCMFormatFlagsSampleFractionMask) &gt;&gt; kLinearPCMFormatFlagsSampleFractionShift;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (fracbits &gt; 0)<span></span></pre></td></tr><tr><td scope="row"><pre>            sprintf(bitdepth, "%d.%d", (int)mBitsPerChannel - fracbits, fracbits);<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>            sprintf(bitdepth, "%d", (int)mBitsPerChannel);<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        nc = snprintf(buf, bufsize, "%s-bit%s%s %s%s%s%s%s",<span></span></pre></td></tr><tr><td scope="row"><pre>            bitdepth, endian, sign, floatInt, <span></span></pre></td></tr><tr><td scope="row"><pre>            commaSpace, packed, align, deinter);<span></span></pre></td></tr><tr><td scope="row"><pre>        //buf += nc; bufsize -= nc;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (mFormatID == 'alac') {   //  kAudioFormatAppleLossless<span></span></pre></td></tr><tr><td scope="row"><pre>        int sourceBits = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        switch (mFormatFlags)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            case 1: //  kAppleLosslessFormatFlag_16BitSourceData<span></span></pre></td></tr><tr><td scope="row"><pre>                sourceBits = 16;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case 2: //  kAppleLosslessFormatFlag_20BitSourceData<span></span></pre></td></tr><tr><td scope="row"><pre>                sourceBits = 20;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case 3: //  kAppleLosslessFormatFlag_24BitSourceData<span></span></pre></td></tr><tr><td scope="row"><pre>                sourceBits = 24;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            case 4: //  kAppleLosslessFormatFlag_32BitSourceData<span></span></pre></td></tr><tr><td scope="row"><pre>                sourceBits = 32;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if (sourceBits)<span></span></pre></td></tr><tr><td scope="row"><pre>            nc = snprintf(buf, bufsize, "from %d-bit source, ", sourceBits);<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            nc = snprintf(buf, bufsize, "from UNKNOWN source bit depth, ");<span></span></pre></td></tr><tr><td scope="row"><pre>        buf += nc; bufsize -= nc;<span></span></pre></td></tr><tr><td scope="row"><pre>        nc = snprintf(buf, bufsize, "%d frames/packet", (int)mFramesPerPacket);<span></span></pre></td></tr><tr><td scope="row"><pre>        //buf += nc; bufsize -= nc;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        nc = snprintf(buf, bufsize, "%d bits/channel, %d bytes/packet, %d frames/packet, %d bytes/frame", <span></span></pre></td></tr><tr><td scope="row"><pre>            (int)mBitsPerChannel, (int)mBytesPerPacket, (int)mFramesPerPacket, (int)mBytesPerFrame);<span></span></pre></td></tr><tr><td scope="row"><pre>    return theBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void    CAStreamBasicDescription::NormalizeLinearPCMFormat(AudioStreamBasicDescription&amp; ioDescription)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //  the only thing that changes is to make mixable linear PCM into the canonical linear PCM format<span></span></pre></td></tr><tr><td scope="row"><pre>    if((ioDescription.mFormatID == kAudioFormatLinearPCM) &amp;&amp; ((ioDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        //  the canonical linear PCM format<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mFormatFlags = kAudioFormatFlagsCanonical;<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mBytesPerPacket = sizeof(AudioSampleType) * ioDescription.mChannelsPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mFramesPerPacket = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mBytesPerFrame = sizeof(AudioSampleType) * ioDescription.mChannelsPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mBitsPerChannel = 8 * sizeof(AudioSampleType);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void    CAStreamBasicDescription::ResetFormat(AudioStreamBasicDescription&amp; ioDescription)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mSampleRate = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mFormatID = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mBytesPerPacket = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mFramesPerPacket = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mBytesPerFrame = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mChannelsPerFrame = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mBitsPerChannel = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    ioDescription.mFormatFlags = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void    CAStreamBasicDescription::FillOutFormat(AudioStreamBasicDescription&amp; ioDescription, const AudioStreamBasicDescription&amp; inTemplateDescription)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if(fiszero(ioDescription.mSampleRate))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mSampleRate = inTemplateDescription.mSampleRate;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mFormatID == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mFormatID = inTemplateDescription.mFormatID;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mFormatFlags == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mFormatFlags = inTemplateDescription.mFormatFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mBytesPerPacket == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mBytesPerPacket = inTemplateDescription.mBytesPerPacket;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mFramesPerPacket == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mFramesPerPacket = inTemplateDescription.mFramesPerPacket;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mBytesPerFrame == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mBytesPerFrame = inTemplateDescription.mBytesPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mChannelsPerFrame == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mChannelsPerFrame = inTemplateDescription.mChannelsPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if(ioDescription.mBitsPerChannel == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        ioDescription.mBitsPerChannel = inTemplateDescription.mBitsPerChannel;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void    CAStreamBasicDescription::GetSimpleName(const AudioStreamBasicDescription&amp; inDescription, char* outName, bool inAbbreviate)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    switch(inDescription.mFormatID)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kAudioFormatLinearPCM:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                const char* theEndianString = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>                if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsBigEndian) != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    #if TARGET_RT_LITTLE_ENDIAN<span></span></pre></td></tr><tr><td scope="row"><pre>                        theEndianString = "Big Endian";<span></span></pre></td></tr><tr><td scope="row"><pre>                    #endif<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    #if TARGET_RT_BIG_ENDIAN<span></span></pre></td></tr><tr><td scope="row"><pre>                        theEndianString = "Little Endian";<span></span></pre></td></tr><tr><td scope="row"><pre>                    #endif<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                const char* theKindString = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>                if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsFloat) != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    theKindString = (inAbbreviate ? "Float" : "Floating Point");<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsSignedInteger) != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    theKindString = (inAbbreviate ? "SInt" : "Signed Integer");<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    theKindString = (inAbbreviate ? "UInt" : "Unsigned Integer");<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                const char* thePackingString = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>                if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsPacked) == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    if((inDescription.mFormatFlags &amp; kAudioFormatFlagIsAlignedHigh) != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        thePackingString = "High";<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                    else<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        thePackingString = "Low";<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                const char* theMixabilityString = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>                if((inDescription.mFormatFlags &amp; kIsNonMixableFlag) == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    theMixabilityString = "Mixable";<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    theMixabilityString = "Unmixable";<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                <span></span></pre></td></tr><tr><td scope="row"><pre>                if(inAbbreviate)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    if(theEndianString != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        if(thePackingString != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Ch %s %s %s%d/%s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, theEndianString, thePackingString, theKindString, (int)inDescription.mBitsPerChannel, theKindString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                        else<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Ch %s %s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, theEndianString, theKindString, (int)inDescription.mBitsPerChannel);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                    else<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        if(thePackingString != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Ch %s %s%d/%s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, thePackingString, theKindString, (int)inDescription.mBitsPerChannel, theKindString, (int)((inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8));<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                        else<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Ch %s%d", theMixabilityString, (int)inDescription.mChannelsPerFrame, theKindString, (int)inDescription.mBitsPerChannel);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                else<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    if(theEndianString != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        if(thePackingString != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Channel %d Bit %s %s Aligned %s in %d Bits", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theEndianString, theKindString, thePackingString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                        else<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Channel %d Bit %s %s", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theEndianString, theKindString);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                    else<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        if(thePackingString != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Channel %d Bit %s Aligned %s in %d Bits", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theKindString, thePackingString, (int)(inDescription.mBytesPerFrame / inDescription.mChannelsPerFrame) * 8);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                        else<span></span></pre></td></tr><tr><td scope="row"><pre>                        {<span></span></pre></td></tr><tr><td scope="row"><pre>                            sprintf(outName, "%s %d Channel %d Bit %s", theMixabilityString, (int)inDescription.mChannelsPerFrame, (int)inDescription.mBitsPerChannel, theKindString);<span></span></pre></td></tr><tr><td scope="row"><pre>                        }<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        case kAudioFormatAC3:<span></span></pre></td></tr><tr><td scope="row"><pre>            strcpy(outName, "AC-3");<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        case kAudioFormat60958AC3:<span></span></pre></td></tr><tr><td scope="row"><pre>            strcpy(outName, "AC-3 for SPDIF");<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            CACopy4CCToCString(outName, inDescription.mFormatID);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#if CoreAudio_Debug<span></span></pre></td></tr><tr><td scope="row"><pre>#include "CALogMacros.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void    CAStreamBasicDescription::PrintToLog(const AudioStreamBasicDescription&amp; inDesc)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintFloat      ("  Sample Rate:        ", inDesc.mSampleRate);<span></span></pre></td></tr><tr><td scope="row"><pre>    Print4CharCode  ("  Format ID:          ", inDesc.mFormatID);<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintHex        ("  Format Flags:       ", inDesc.mFormatFlags);<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintInt        ("  Bytes per Packet:   ", inDesc.mBytesPerPacket);<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintInt        ("  Frames per Packet:  ", inDesc.mFramesPerPacket);<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintInt        ("  Bytes per Frame:    ", inDesc.mBytesPerFrame);<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintInt        ("  Channels per Frame: ", inDesc.mChannelsPerFrame);<span></span></pre></td></tr><tr><td scope="row"><pre>    PrintInt        ("  Bits per Channel:   ", inDesc.mBitsPerChannel);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool    operator&lt;(const AudioStreamBasicDescription&amp; x, const AudioStreamBasicDescription&amp; y)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    bool theAnswer = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    bool isDone = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  note that if either side is 0, that field is skipped<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  format ID is the first order sort<span></span></pre></td></tr><tr><td scope="row"><pre>    if((!isDone) &amp;&amp; ((x.mFormatID != 0) &amp;&amp; (y.mFormatID != 0)))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if(x.mFormatID != y.mFormatID)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            //  formats are sorted numerically except that linear<span></span></pre></td></tr><tr><td scope="row"><pre>            //  PCM is always first<span></span></pre></td></tr><tr><td scope="row"><pre>            if(x.mFormatID == kAudioFormatLinearPCM)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                theAnswer = true;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else if(y.mFormatID == kAudioFormatLinearPCM)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                theAnswer = false;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                theAnswer = x.mFormatID &lt; y.mFormatID;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  mixable is always better than non-mixable for linear PCM and should be the second order sort item<span></span></pre></td></tr><tr><td scope="row"><pre>    if((!isDone) &amp;&amp; ((x.mFormatID == kAudioFormatLinearPCM) &amp;&amp; (y.mFormatID == kAudioFormatLinearPCM)))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if(((x.mFormatFlags &amp; kIsNonMixableFlag) == 0) &amp;&amp; ((y.mFormatFlags &amp; kIsNonMixableFlag) != 0))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnswer = true;<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else if(((x.mFormatFlags &amp; kIsNonMixableFlag) != 0) &amp;&amp; ((y.mFormatFlags &amp; kIsNonMixableFlag) == 0))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnswer = false;<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  floating point vs integer for linear PCM only<span></span></pre></td></tr><tr><td scope="row"><pre>    if((!isDone) &amp;&amp; ((x.mFormatID == kAudioFormatLinearPCM) &amp;&amp; (y.mFormatID == kAudioFormatLinearPCM)))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if((x.mFormatFlags &amp; kAudioFormatFlagIsFloat) != (y.mFormatFlags &amp; kAudioFormatFlagIsFloat))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            //  floating point is better than integer<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnswer = y.mFormatFlags &amp; kAudioFormatFlagIsFloat;<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  bit depth<span></span></pre></td></tr><tr><td scope="row"><pre>    if((!isDone) &amp;&amp; ((x.mBitsPerChannel != 0) &amp;&amp; (y.mBitsPerChannel != 0)))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if(x.mBitsPerChannel != y.mBitsPerChannel)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            //  deeper bit depths are higher quality<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnswer = x.mBitsPerChannel &lt; y.mBitsPerChannel;<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  sample rate<span></span></pre></td></tr><tr><td scope="row"><pre>    if((!isDone) &amp;&amp; fnonzero(x.mSampleRate) &amp;&amp; fnonzero(y.mSampleRate))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if(fnotequal(x.mSampleRate, y.mSampleRate))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            //  higher sample rates are higher quality<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnswer = x.mSampleRate &lt; y.mSampleRate;<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    //  number of channels<span></span></pre></td></tr><tr><td scope="row"><pre>    if((!isDone) &amp;&amp; ((x.mChannelsPerFrame != 0) &amp;&amp; (y.mChannelsPerFrame != 0)))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if(x.mChannelsPerFrame != y.mChannelsPerFrame)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            //  more channels is higher quality<span></span></pre></td></tr><tr><td scope="row"><pre>            theAnswer = x.mChannelsPerFrame &lt; y.mChannelsPerFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>            isDone = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return theAnswer;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static bool MatchFormatFlags(const AudioStreamBasicDescription&amp; x, const AudioStreamBasicDescription&amp; y)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 xFlags = x.mFormatFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 yFlags = y.mFormatFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    // match wildcards<span></span></pre></td></tr><tr><td scope="row"><pre>    if (x.mFormatID == 0 || y.mFormatID == 0 || xFlags == 0 || yFlags == 0) <span></span></pre></td></tr><tr><td scope="row"><pre>        return true;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    if (x.mFormatID == kAudioFormatLinearPCM)<span></span></pre></td></tr><tr><td scope="row"><pre>    {               <span></span></pre></td></tr><tr><td scope="row"><pre>        // knock off the all clear flag<span></span></pre></td></tr><tr><td scope="row"><pre>        xFlags = xFlags &amp; ~kAudioFormatFlagsAreAllClear;<span></span></pre></td></tr><tr><td scope="row"><pre>        yFlags = yFlags &amp; ~kAudioFormatFlagsAreAllClear;<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>        // if both kAudioFormatFlagIsPacked bits are set, then we don't care about the kAudioFormatFlagIsAlignedHigh bit.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (xFlags &amp; yFlags &amp; kAudioFormatFlagIsPacked) {<span></span></pre></td></tr><tr><td scope="row"><pre>            xFlags = xFlags &amp; ~kAudioFormatFlagIsAlignedHigh;<span></span></pre></td></tr><tr><td scope="row"><pre>            yFlags = yFlags &amp; ~kAudioFormatFlagIsAlignedHigh;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        // if both kAudioFormatFlagIsFloat bits are set, then we don't care about the kAudioFormatFlagIsSignedInteger bit.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (xFlags &amp; yFlags &amp; kAudioFormatFlagIsFloat) {<span></span></pre></td></tr><tr><td scope="row"><pre>            xFlags = xFlags &amp; ~kAudioFormatFlagIsSignedInteger;<span></span></pre></td></tr><tr><td scope="row"><pre>            yFlags = yFlags &amp; ~kAudioFormatFlagIsSignedInteger;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        //  if the bit depth is 8 bits or less and the format is packed, we don't care about endianness<span></span></pre></td></tr><tr><td scope="row"><pre>        if((x.mBitsPerChannel &lt;= 8) &amp;&amp; ((xFlags &amp; kAudioFormatFlagIsPacked) == kAudioFormatFlagIsPacked))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            xFlags = xFlags &amp; ~kAudioFormatFlagIsBigEndian;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        if((y.mBitsPerChannel &lt;= 8) &amp;&amp; ((yFlags &amp; kAudioFormatFlagIsPacked) == kAudioFormatFlagIsPacked))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            yFlags = yFlags &amp; ~kAudioFormatFlagIsBigEndian;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>        //  if the number of channels is 0 or 1, we don't care about non-interleavedness<span></span></pre></td></tr><tr><td scope="row"><pre>        if (x.mChannelsPerFrame &lt;= 1 &amp;&amp; y.mChannelsPerFrame &lt;= 1) {<span></span></pre></td></tr><tr><td scope="row"><pre>            xFlags &amp;= ~kLinearPCMFormatFlagIsNonInterleaved;<span></span></pre></td></tr><tr><td scope="row"><pre>            yFlags &amp;= ~kLinearPCMFormatFlagIsNonInterleaved;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return xFlags == yFlags;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool    operator==(const AudioStreamBasicDescription&amp; x, const AudioStreamBasicDescription&amp; y)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    //  the semantics for equality are:<span></span></pre></td></tr><tr><td scope="row"><pre>    //      1) Values must match exactly<span></span></pre></td></tr><tr><td scope="row"><pre>    //      2) wildcard's are ignored in the comparison<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>#define MATCH(name) ((x.name) == 0 || (y.name) == 0 || (x.name) == (y.name))<span></span></pre></td></tr><tr><td scope="row"><pre>    <span></span></pre></td></tr><tr><td scope="row"><pre>    return <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the sample rate<span></span></pre></td></tr><tr><td scope="row"><pre>        (fiszero(x.mSampleRate) || fiszero(y.mSampleRate) || fequal(x.mSampleRate, y.mSampleRate))<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the format ids<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MATCH(mFormatID)<span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the format flags<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MatchFormatFlags(x, y)  <span></span></pre></td></tr><tr><td scope="row"><pre>            <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the bytes per packet<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MATCH(mBytesPerPacket) <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the frames per packet<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MATCH(mFramesPerPacket) <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the bytes per frame<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MATCH(mBytesPerFrame) <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the channels per frame<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MATCH(mChannelsPerFrame) <span></span></pre></td></tr><tr><td scope="row"><pre>        <span></span></pre></td></tr><tr><td scope="row"><pre>            //  check the channels per frame<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; MATCH(mBitsPerChannel) ;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool    CAStreamBasicDescription::IsEqual(const AudioStreamBasicDescription &amp;other, bool interpretingWildcards) const<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (interpretingWildcards)<span></span></pre></td></tr><tr><td scope="row"><pre>        return *this == other;<span></span></pre></td></tr><tr><td scope="row"><pre>    return memcmp(this, &amp;other, offsetof(AudioStreamBasicDescription, mReserved)) == 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bool SanityCheck(const AudioStreamBasicDescription&amp; x)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // This function returns false if there are sufficiently insane values in any field.<span></span></pre></td></tr><tr><td scope="row"><pre>    // It is very conservative so even some very unlikely values will pass.<span></span></pre></td></tr><tr><td scope="row"><pre>    // This is just meant to catch the case where the data from a file is corrupted.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return <span></span></pre></td></tr><tr><td scope="row"><pre>        (x.mSampleRate &gt;= 0.)   <span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; (x.mBytesPerPacket &lt; 1000000)<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; (x.mFramesPerPacket &lt; 1000000)<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; (x.mBytesPerFrame &lt; 1000000)<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; (x.mChannelsPerFrame &lt;= 1024)<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;&amp; (x.mBitsPerChannel &lt;= 1024);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='iPublicUtility_CAStreamBasicDescription_h.html'>Next</a><a class='previousLink' rel='prev' href='iPublicUtility_CAMath_h.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> &#x00a9; 2010 Apple Inc. All Rights Reserved. &#40;Last updated: 2010-06-28&#041;</p></div></div>

        <div id="feedbackForm" class="hideOnPrint" style="margin-left: auto; margin-right: auto; width: 38em; margin-bottom: 15px; margin-top: 15px; font-weight: bold; color: #333333; background: #d9d9d9; padding: 5px 10px 5px 10px; height: 15px; text-align: center; -webkit-border-radius: 12px; -moz-border-radius: 12px; vertical-align: middle;">
    Did this document help you?
    <span class="tooltip" data-abstract="<b>Yes:</b> Tell us what works for you.">
       <a href="http://developer.apple.com/feedback/?v=1&url=%2Flibrary%2Fios%2Fsamplecode%2FAQOfflineRenderTest%2FListings%2FiPublicUtility_CAStreamBasicDescription_cpp.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_2.iOSLibrary-37.55%26id%3DDTS40008413-2.1&media=xcode" class='urlLink'>Yes</a>
    </span>
    <span class="tooltip" data-abstract="<b>It's good, but:</b> Report typos, inaccuracies, and so forth.">
        <a href="http://developer.apple.com/feedback/?v=2&url=%2Flibrary%2Fios%2Fsamplecode%2FAQOfflineRenderTest%2FListings%2FiPublicUtility_CAStreamBasicDescription_cpp.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_2.iOSLibrary-37.55%26id%3DDTS40008413-2.1&media=xcode" class='urlLink'>It's good, but...</a>
    </span>
    <span class="tooltip" data-abstract="<b>Not helpful:</b> Tell us what would have helped.">
        <a href="http://developer.apple.com/feedback/?v=3&url=%2Flibrary%2Fios%2Fsamplecode%2FAQOfflineRenderTest%2FListings%2FiPublicUtility_CAStreamBasicDescription_cpp.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_2.iOSLibrary-37.55%26id%3DDTS40008413-2.1&media=xcode" class='urlLink'>Not helpful...</a>
    </span>
</div>
        
        <!-- /CONTENTS -->
    </article>
</body>
<script charset="utf-8" src="../../../Resources/545/JavaScript/lib/prototype.js"></script>
<!-- Media player includes -->
<script charset="utf-8" src="../../../Resources/545/JavaScript/lib/scriptaculous.js"></script>
<script charset="utf-8" src="../../../Resources/545/JavaScript/lib/event_mixins.js"></script>
<script charset="utf-8" src="../../../Resources/545/JavaScript/lib/browserdetect.js"></script>
<script charset="utf-8" src="../../../Resources/545/JavaScript/lib/ac_media.js"></script>
<!-- /Media player includes -->
<script charset="utf-8" src="../../../Resources/545/JavaScript/devpubs.js"></script>
<script charset="utf-8" src="../../../Resources/545/JavaScript/book.js"></script>
</html>